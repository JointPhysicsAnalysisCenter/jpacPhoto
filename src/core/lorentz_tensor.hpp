// Custom implementation of Lorentz tensors.
// These are assembled by the outer/tensor products of vectors
//
// ------------------------------------------------------------------------------
// Author:       Daniel Winney (2022)
// Affiliation:  Joint Physics Analysis Center (JPAC)
// Email:        dwinney@iu.edu
// ------------------------------------------------------------------------------

#ifndef LORENTZ_TENSOR_HPP
#define LORENTZ_TENSOR_HPP

#include <vector>

#include "constants.hpp"
#include "lorentz_vector.hpp"

namespace jpacPhoto
{
    // -----------------------------------------------------------------------
    // We can think of objects with more than one index.
    // In most useful contexts, these come from outer products of vectors 
    // This class describes an arbitrary rank tensor created iteratively 

    template<int Rank>
    class lorentz_tensor
    {
        public: 

        // These enums allows us to specify if a given tensor requires special treatment
        enum special_tensors { kNone, kMetric, kSum };

        // Assignment which "captures" a vector and turns it nto a ranke 1 tensor
        lorentz_tensor<Rank>(lorentz_vector const & v)
        : _indices({v})
        {
            if (_rank != 1) warning("lorentz_tensor", "Tensor defined from vector with rank != 1!");
        };

        // Accessor function for elements 
        inline complex operator[](std::array<lorentz_index,Rank> vals)
        {
            if (vals.size() != Rank ) return error("lorentz_tensor[]", "Incorrect number of indices passed.", NaN<complex>());
            
            if (_option == kMetric) return _N * metric(vals[0], vals[1]);
            return _N * element(vals);
        };

        // Get the rank of the tensor (number of open indicies)
        inline int rank(){ return _rank; };

        // Re-assignment
        inline lorentz_tensor<Rank> & operator=(lorentz_tensor<Rank> const & T)
        {
            _indices        = T._indices;
            _conj           = T._conj;
            _option         = T._option;
            _tensors_to_sum = T._tensors_to_sum;
            return *this;
        };

        // Multiply and divide by a constant
        inline lorentz_tensor<Rank> & operator*=(complex c)
        {
            // Apply the constant to the first index simply
            _N *= c;
            return *this;
        };

        inline lorentz_tensor<Rank> & operator/=(complex c)
        {
            _N *= (1./c);
            return *this;
        };

        // Negate a tensor
        inline lorentz_tensor<Rank> & operator-()
        {
            _N*= -1.; 
            return *this;
        };

        // Return a copy of itself with the conj flag flipped
        inline lorentz_tensor<Rank> conjugate()
        {
            return lorentz_tensor<Rank>(_indices, !_conj);
        };

        private:

        // Constructor for a single tensor, generated by tensor product of list of vectors size-Rank
        lorentz_tensor<Rank>(std::array<lorentz_vector,Rank> list, bool if_conj = false)
        : _conj(if_conj), _indices(list)
        {};

        lorentz_tensor<Rank>(special_tensors x)
        : _option(x)
        {};

        // Make the outer product class a friend which can access the _indices
        // This makes it clear that although lorentz_tensor is  generic class
        // Currently its implementation only fully allows those tensors decomposable as
        // tensor products of spin-1 subspaces
        friend class lorentz_vector;
        template<int R>
        friend lorentz_tensor<R> outer_product(std::array<lorentz_vector,R>);
    
        // Rest of these classes exist outside the class but form the core ways to interact
        // with tensors

        // Sum vectors together
        template<int R>
        friend lorentz_tensor<R> operator+(lorentz_tensor<R> lhs, lorentz_tensor<R> rhs);

        // Special metric tensor 
        friend lorentz_tensor<2> metric_tensor();

        // For rank 0 and 1, we can flatten down to get a vector or scalar respectively
        friend complex        flatten(lorentz_tensor<0> T);
        friend lorentz_vector flatten(lorentz_tensor<1> T);


        // The element calculated from the elements of each subspace
        inline complex element(std::array<lorentz_index,Rank> vals)
        {
            complex result; 

            // If this tensor is a sum of tensors,
            // simply iterate over each subtensor which handles its own element calculation
            if ( _option == kSum)
            {
                result = 0.;
                for (auto tensor : _tensors_to_sum)
                {
                    result += tensor[vals];
                }
            }
            else
            {
                // If its not a sum, simply iterate over the saved vectors and 
                // calculate the tensor product by element-wise multiplication
                result = 1.;
                for (int i = 0; i < Rank; i++)
                {
                    result *= _indices[i][vals[i]];
                };
            }

            // Complex conjugate if desired
            return (_conj) ? std::conj(result) : result;
        };

        const static int _rank = Rank;
        bool _conj = false;
        
        // If this tensor represents a single one, we store its indices
        std::array<lorentz_vector,Rank> _indices;

        // This flag marks whether or not this tensor is a special case
        // Defaults to non-special (i.e. usual tensor product)
        special_tensors _option = kNone;

        // If the tensor is a metric, it may still be multiplied by a constant.
        complex _N = 1.;

        // If not, we the tensor serves as a store of constituent other tensors 
        // which are summed element wise instead
        std::vector<lorentz_tensor> _tensors_to_sum;
        void add_tensor(lorentz_tensor T)
        {
            if (_option != kSum) return error("add_tensor()", "Cannot add tensor to pre-initialized one. Initilize a new tensor as the sum!");
            _tensors_to_sum.push_back(T); 
        };
    };

    // Outer product of any number of lorentz_vectors produces a tensor
    template<int R>
    inline lorentz_tensor<R> outer_product(std::array<lorentz_vector,R> xs)
    {   
        return lorentz_tensor<R>(xs, false); 
    };

    // The metric tensor is unique rank-2 tensor as it cannot be decomposed into a tensor product
    // of rank-1 vectors
    inline lorentz_tensor<2> metric_tensor()
    {
        return lorentz_tensor<2>(lorentz_tensor<2>::special_tensors::kMetric);
    };

    // Add two tensors together
    template<int R>
    inline lorentz_tensor<R> operator+(lorentz_tensor<R> lhs, lorentz_tensor<R> rhs)
    {
        lorentz_tensor<R> result(lorentz_tensor<R>::special_tensors::kSum);
        result.add_tensor(lhs);
        result.add_tensor(rhs);
        return result;
    };

    // Subtract two tensors
    template<int R>
    inline lorentz_tensor<R> operator-(lorentz_tensor<R> lhs, lorentz_tensor<R> rhs)
    {
        return lhs + (-rhs);
    };

    // Be able to multiply a tensor by a constant from the right
    template<int R>
    inline lorentz_tensor<R> operator*(complex c, lorentz_tensor<R> T)
    {
        lorentz_tensor<R> Tp(T);
        Tp *= c;
        return Tp;
    };

    // Multiplication by a constant from the left
    template<int R>
    inline lorentz_tensor<R> operator*(lorentz_tensor<R> T, complex c)
    {
        return c*T;
    };

    // Divide by a constant
    template<int R>
    inline lorentz_tensor<R> operator/(lorentz_tensor<R> T, complex c)
    {
        return (1./c)*T;
    };
    
    // ---------------------------------------------------------------------------
    // Non-member (and non-template) methods

    // Low rank tensors may be flattened to scalar and vector respectively
    complex        flatten(lorentz_tensor<0> T);
    lorentz_vector flatten(lorentz_tensor<1> T);

    // ---------------------------------------------------------------------------
    // Contractions between tensors

    // Contractions of multiple tensors into scalars
    complex contract(lorentz_tensor<0> left, lorentz_tensor<0> right);
    complex contract(lorentz_tensor<1> left, lorentz_tensor<1> right);
    complex contract(lorentz_tensor<1> bra,  lorentz_tensor<2> T, lorentz_tensor<1> ket);
};

#endif